/*

Домашнее задание
Генерация адаптеров по интерфейсу

Цель:
В рамках данного ДЗ Вы научитесь генерировать адаптеры для интерфейсов, полученных при применении принципа DIP.
ДЗ демонстрирует применение метапрограммирования для решения рутинных задач, а также возможности Reflection и компиляции "на лету" современных языков программирования.

Если задание выполняется на C++, то задание заключается в написании препроцессора, который ищет абстрактные классы и по ним генерирует код адаптера, который включается в состав проекта. Для удобства такой препроцессор стоит запускать на этапе, предшествующем компиляции в процессе сборки, а также стоит подумать об удалении всех
сгенерированных файлов при выполнении команды clear.


Описание/Пошаговая инструкция выполнения домашнего задания:
Предположим, что у нас есть интерфейс
interface Spaceship.Operations.IMovable
{
    Vector getPosition();
    void setPosition(Vector newValue);
    Vector getVelocity();
}

Необходимо по нему сгенерировать следующий класс:
class AutoGenerated.MovableAdapter: Spaceship.Operations.IMovable
{
    UObject obj;
    public MovableAdapter(UObject obj)
    {
        this.obj = obj;
    }

    public Vector getPosition()
    {
        return IoC.Resolve("Spaceship.Operations.IMovable:position.get", obj);
    }

    public Vector getVelocity()
    {
        return IoC.Resolve("Spaceship.Operations.IMovable:velocity.get", obj);
    }

    public void setPosition(Vector newValue)
    {
        IoC.Resolve("Spaceship.Operations.IMovable:position.set", obj, newValue).Execute();
    }
}

так, чтобы можно было создавать экземпляры этого класса.

Экземпляры генерируемых оберток для объекта obj можно создавать следующей строкой:
var adapter = IoC.Resolve("Adapter", typeof(IMovable), obj);

3*. Необязательная задача на подумать: если интерфейсе потребуются какие-либо методы, например, как
interface Spaceship.Operations.IMovable
{
    Vector getPosition();
    Vector setPosition(Vector newValue);
    Vector getVelocity();
    void finish();
}
Придумать реализацию адаптера для подобных методов.

Критерии оценки:

Задание сдано на проверку - 1 балл
Реализован генератор адаптеров - 3 балла
Реализованы тесты на генератор адаптеров - 2 балл
Определена стратегия для IoC из п. 2 задания - 2 балла
Обработан случай из п. 3 задания - 2 балла

-----------------------------------------------------------------
- надо использовать рефлексию, анализировать свойства и методы интерфейса
- искать RuntimeCodeGeneration 
*/

using System;
using Xunit;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Concurrent;
using HomeWorkFour;
using HomeWorkFive;

namespace HomeWorkSix
{
    class MovingAdapter : IMoving
    {
        private IDictionary<string, object> _map;
        public MovingAdapter (IDictionary<string, object> map)
        {
            _map = map;
        }
        public Vector GetLocation()
        {
            return IoC.Resolve<Vector>("IMoving.Location.Get", _map);
        }
        public Vector GetVelocity()
        {
            return IoC.Resolve<Vector>("IMoving.Velocity.Get", _map);
        }
        public void SetLocation(Vector newValue)
        {
            IoC.Resolve<ICommand>("IMoving.Location.Set", _map, newValue).Execute();
        }
    }

    class CodeComposer
    {
        // предполагается, что зависимости именуются в IoC-контейнере так: Interface.Abstraction.Action
        //                                                       например: IMoving.Velocity.Get
        /*
            obj.GetType() - информация о типе
            obj.GetType().GetInterfaces() - список интерфейсов, интерфейсы - тоже типы
            obj.GetType().GetInterfaces[].GetMethods() - список методов
            - список параметров
        */
        public static string CreateObject(Type type)
        {
            // получить список интерфейсов, унаследованных данным типом
            Type[] interfaces = type.GetInterfaces();
            // для каждого интерфейса получить список методов
            foreach(Type interface)
            {

            }

            // получить список методов самого типа
        }

        public static string BuildMethod(string interfaceName, string typeName, string propertyName, string action) 
        {
            return $"public {typeName} {action}{propertyName}() { return IoC.Resolve<{{typeName}}>(""{interfaceName}.{propertyName}.{action}"", _map); }";
        }
    }

    // вынести в отдельный плагин, в котором прописать доступные объекты
    public class RegisterGameDependenciesCommand : ICommand
    {
        public RegisterGameDependenciesCommand()
        {
        }
        public void Execute()
        {
            (new InitCommand()).Execute();

//            IoC.Resolve<Vector>("IoC.Register", "Sequencies.Interfaces", ["IMoving", "IRotating"]).Execute();
//            IoC.Resolve<Vector>("IoC.Register", "Sequencies.Abstractions", ["Velocity", "Location"]).Execute();
//            IoC.Resolve<Vector>("IoC.Register", "Sequencies.Actions", ["Get", "Set"]).Execute();

            IoC.Resolve<Vector>("IoC.Register", "IMoving.Location.Get", (object[] args) => {
                return (Vector)args[0]["Location"];
            }).Execute();

            IoC.Resolve<ICommand>("IoC.Register", "IMoving.Location.Set", (object[] args) => {
                args[0]["Location"] = args[1];
            }).Execute();

            IoC.Resolve<ICommand>("IoC.Register", "IMoving.Velocity.Get", (object[] args) => {
                Angle angle = (Angle)args[0]["Angle"];
                int velocity = (int)args[0]["Velocity"];
                return new Vector(
                    velocity * Math.Cos(angle.ToDouble()),
                    velocity * Math.Sin(angle.ToDouble())
                );
            }).Execute();
        }
    }

    public class Game : ICommand
    {
        public Game()
        {
        }
        public void Execute()
        {
            new RegisterGameDependenciesCommand().Execute();
        }
    }

}


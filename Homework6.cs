/*

Домашнее задание
Генерация адаптеров по интерфейсу

Цель:
В рамках данного ДЗ Вы научитесь генерировать адаптеры для интерфейсов, полученных при применении принципа DIP.
ДЗ демонстрирует применение метапрограммирования для решения рутинных задач, а также возможности Reflection и компиляции "на лету" современных языков программирования.

Описание/Пошаговая инструкция выполнения домашнего задания:
Предположим, что у нас есть интерфейс
interface Spaceship.Operations.IMovable
{
    Vector getPosition();
    void setPosition(Vector newValue);
    Vector getVelocity();
}

Необходимо по нему сгенерировать следующий класс:
class AutoGenerated.MovableAdapter: Spaceship.Operations.IMovable
{
    UObject obj;
    public MovableAdapter(UObject obj)
    {
        this.obj = obj;
    }

    public Vector getPosition()
    {
        return IoC.Resolve("Spaceship.Operations.IMovable:position.get", obj);
    }

    public Vector getVelocity()
    {
        return IoC.Resolve("Spaceship.Operations.IMovable:velocity.get", obj);
    }

    public void setPosition(Vector newValue)
    {
        IoC.Resolve("Spaceship.Operations.IMovable:position.set", obj, newValue).Execute();
    }
}

так, чтобы можно было создавать экземпляры этого класса.

Экземпляры генерируемых оберток для объекта obj можно создавать следующей строкой:
var adapter = IoC.Resolve("Adapter", typeof(IMovable), obj);

3*. Необязательная задача на подумать: если интерфейсе потребуются какие-либо методы, например, как
interface Spaceship.Operations.IMovable
{
    Vector getPosition();
    Vector setPosition(Vector newValue);
    Vector getVelocity();
    void finish();
}
Придумать реализацию адаптера для подобных методов.

Критерии оценки:

OK Задание сдано на проверку - 1 балл
OK Реализован генератор адаптеров - 3 балла
Реализованы тесты на генератор адаптеров - 2 балл
OK Определена стратегия для IoC из п. 2 задания - 2 балла
OK Обработан случай из п. 3 задания - 2 балла

*/

using System;
using Xunit;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Text;
using System.Reflection;
using HomeWorkFour;
using HomeWorkFive;

namespace HomeWorkSix
{
    /*
    class MovingAdapter : IMoving
    {
        private IDictionary<string, object> _map;
        public MovingAdapter (IDictionary<string, object> map)
        {
            _map = map;
        }
        public Vector GetLocation()
        {
            return IoC.Resolve<Vector>("IMoving.Location.Get", _map);
        }
        public Vector GetVelocity()
        {
            return IoC.Resolve<Vector>("IMoving.Velocity.Get", _map);
        }
        public void SetLocation(Vector newValue)
        {
            IoC.Resolve<ICommand>("IMoving.Location.Set", _map, newValue).Execute();
        }
    }
    */

    class CodeComposer
    {
        public static string BuildClass(Type type)
        {
            // получить список методов
            System.Reflection.MethodInfo[] methods = type.GetMethods();

            StringBuilder methodsCode = new StringBuilder("");

            foreach(MethodInfo method in methods)
            {
                methodsCode.Append(BuildProperty(type.Name, method.ReturnType.Name, method.Name, method.GetParameters()));
            }

            return $"class {type.Name}Adapter : {type.Name}" + 
                $"{{" +
                    $"private IDictionary<string, object> _map;" +
                    $"public {type.Name}Adapter (IDictionary<string, object> map) {{ _map = map; }}"+
                    $"{methodsCode}" +
                $"}}";
        }

        public static string BuildProperty(string interfaceName, string typeName, string propertyName, ParameterInfo[] parameters)
        {
            // OK сконструировать строку перечисления параметров с типами
            // OK сконструировать строку перечисления параметров без типов
            StringBuilder paramsStr = new StringBuilder("");
            StringBuilder paramsTypedStr = new StringBuilder("");
            foreach (ParameterInfo param in parameters)
            {
                paramsStr.Append(", ");
                paramsStr.Append(param.Name);

                if (paramsTypedStr.Length != 0)
                {
                    paramsTypedStr.Append(", ");
                }
                paramsTypedStr.Append(param.ParameterType.Name);
                paramsTypedStr.Append(" ");
                paramsTypedStr.Append(param.Name);
            }
            // OK сделать добавление Execute для типа void
            // OK сделать добавление списков пераметров (с типами и без оных)
            return $"public {typeName} {propertyName}({paramsTypedStr}) {{ return IoC.Resolve<{typeName}>("+"\""+$"{interfaceName}.{propertyName}"+"\""+$", _map{paramsStr}){(typeName == "void" ? ".Execute()" : "")}; }}";
        }
    }

    // вынести в отдельный плагин, в котором прописать доступные объекты
    public class RegisterGameDependenciesCommand : ICommand
    {
        public RegisterGameDependenciesCommand()
        {
        }
        public void Execute()
        {
            (new InitCommand()).Execute();

            IoC.Resolve<ICommand>("IoC.Register", "IMoving.GetLocation", (object[] args) => {
                return (Vector)args[0]["Location"];
            }).Execute();

            IoC.Resolve<ICommand>("IoC.Register", "IMoving.SetLocation", (object[] args) => {
                args[0]["Location"] = args[1];
            }).Execute();

            IoC.Resolve<ICommand>("IoC.Register", "IMoving.GetVelocity", (object[] args) => {
                Angle angle = (Angle)args[0]["Angle"];
                int velocity = (int)args[0]["Velocity"];
                return new Vector(
                    velocity * Math.Cos(angle.ToDouble()),
                    velocity * Math.Sin(angle.ToDouble())
                );
            }).Execute();

            IoC.Resolve("IoC.Register", "Adapter", (object[] args) => {
                return CodeComposer.BuildClass();
            }).Execute();
        }
    }

    public class Game : ICommand
    {
        private IDictionary<string, object> _map;
        public Game()
        {
            _map = new System.Collections.Generic.Dictionary<string, object>;
        }
        public void Execute()
        {
            new RegisterGameDependenciesCommand().Execute();
            var adapter = CodeGenerator.ExecuteCode<IMoving>(IoC.Resolve("Adapter", typeof(IMoving), _map));
        }
    }

}
